/*
** RistrettoDB Amalgamation
**
** This file contains the complete implementation of RistrettoDB in a single
** source file. Simply compile this file along with your application.
**
** To use amalgamation (Option 1 - Self-contained):
**   1. Include this ristretto.c file in your project
**   2. Define RISTRETTO_AMALGAMATION before including
**   3. Example:
**      #define RISTRETTO_AMALGAMATION
**      #include "ristretto.c"  // Note: .c not .h
**
** To use with separate header (Option 2):
**   1. Include ristretto.h in your source files
**   2. Compile ristretto.c separately
**   3. Link together
**
** Generated by amalgamate.py
** RistrettoDB Version: 2.0.0
** Homepage: https://github.com/YourUsername/RistrettoDB
*/

#ifndef RISTRETTO_AMALGAMATION

/* When used as a separate compilation unit, include the public header */
#include "ristretto.h"

#else

/* 
** When used as an amalgamation, provide all definitions inline
** This section replaces ristretto.h when RISTRETTO_AMALGAMATION is defined
*/

#ifndef RISTRETTO_H
#define RISTRETTO_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** RistrettoDB Version Information
*/
#define RISTRETTO_VERSION        "2.0.0"
#define RISTRETTO_VERSION_NUMBER 2000000
#define RISTRETTO_VERSION_MAJOR  2
#define RISTRETTO_VERSION_MINOR  0
#define RISTRETTO_VERSION_PATCH  0

const char* ristretto_version(void);
int ristretto_version_number(void);

/*
** Original SQL API
*/
typedef struct RistrettoDB RistrettoDB;

typedef enum {
    RISTRETTO_OK = 0,
    RISTRETTO_ERROR = -1,
    RISTRETTO_NOMEM = -2,
    RISTRETTO_IO_ERROR = -3,
    RISTRETTO_PARSE_ERROR = -4,
    RISTRETTO_NOT_FOUND = -5,
    RISTRETTO_CONSTRAINT_ERROR = -6
} RistrettoResult;

RistrettoDB* ristretto_open(const char* filename);
void ristretto_close(RistrettoDB* db);
RistrettoResult ristretto_exec(RistrettoDB* db, const char* sql);

typedef void (*RistrettoCallback)(void* ctx, int n_cols, char** values, char** col_names);
RistrettoResult ristretto_query(RistrettoDB* db, const char* sql, RistrettoCallback callback, void* ctx);
const char* ristretto_error_string(RistrettoResult result);

/*
** Table V2 API Constants
*/
#define RISTRETTO_MAX_COLUMNS 14
#define RISTRETTO_MAX_COLUMN_NAME 8
#define RISTRETTO_TABLE_HEADER_SIZE 256
#define RISTRETTO_INITIAL_FILE_SIZE (1024 * 1024)
#define RISTRETTO_GROWTH_FACTOR 2
#define RISTRETTO_SYNC_INTERVAL_ROWS 512
#define RISTRETTO_SYNC_INTERVAL_MS 100
#define RISTRETTO_TABLE_MAGIC "RSTRDB\x00\x00"
#define RISTRETTO_TABLE_VERSION 1

typedef enum {
    RISTRETTO_COL_INTEGER = 1,
    RISTRETTO_COL_REAL = 2,
    RISTRETTO_COL_TEXT = 3,
    RISTRETTO_COL_NULLABLE = 4
} RistrettoColumnType;

typedef struct RistrettoTable RistrettoTable;

typedef struct {
    RistrettoColumnType type;
    union {
        int64_t integer;
        double real;
        struct {
            char *data;
            size_t length;
        } text;
    } value;
    bool is_null;
} RistrettoValue;

typedef struct {
    char name[RISTRETTO_MAX_COLUMN_NAME];
    uint8_t type;
    uint8_t length;
    uint16_t offset;
    uint8_t reserved[4];
} RistrettoColumnDesc;

/*
** Table V2 API Functions
*/
RistrettoTable* ristretto_table_create(const char *name, const char *schema_sql);
RistrettoTable* ristretto_table_open(const char *name);
void ristretto_table_close(RistrettoTable *table);

bool ristretto_table_append_row(RistrettoTable *table, const RistrettoValue *values);
bool ristretto_table_select(RistrettoTable *table, const char *where_clause,
                           void (*callback)(void *ctx, const RistrettoValue *row), void *ctx);

bool ristretto_table_flush(RistrettoTable *table);
size_t ristretto_table_get_row_count(RistrettoTable *table);

RistrettoValue ristretto_value_integer(int64_t val);
RistrettoValue ristretto_value_real(double val);
RistrettoValue ristretto_value_text(const char *str);
RistrettoValue ristretto_value_null(void);
void ristretto_value_destroy(RistrettoValue *value);

/*
** Compatibility layer (when using amalgamation)
*/
#define RistrettoDB                  RistrettoDB
#define RistrettoResult              RistrettoResult
#define RistrettoCallback            RistrettoCallback
#define ristretto_open               ristretto_open
#define ristretto_close              ristretto_close
#define ristretto_exec               ristretto_exec
#define ristretto_query              ristretto_query
#define ristretto_error_string       ristretto_error_string

#define Table                        RistrettoTable
#define Value                        RistrettoValue
#define ColumnDesc                   RistrettoColumnDesc
#define ColumnType                   RistrettoColumnType
#define COL_TYPE_INTEGER             RISTRETTO_COL_INTEGER
#define COL_TYPE_REAL                RISTRETTO_COL_REAL
#define COL_TYPE_TEXT                RISTRETTO_COL_TEXT
#define COL_TYPE_NULLABLE            RISTRETTO_COL_NULLABLE
#define MAX_COLUMNS                  RISTRETTO_MAX_COLUMNS
#define MAX_COLUMN_NAME              RISTRETTO_MAX_COLUMN_NAME

#define table_create                 ristretto_table_create
#define table_open                   ristretto_table_open
#define table_close                  ristretto_table_close
#define table_append_row             ristretto_table_append_row
#define table_select                 ristretto_table_select
#define table_flush                  ristretto_table_flush
#define table_get_row_count          ristretto_table_get_row_count
#define value_integer                ristretto_value_integer
#define value_real                   ristretto_value_real
#define value_text                   ristretto_value_text
#define value_null                   ristretto_value_null
#define value_destroy                ristretto_value_destroy

#ifdef __cplusplus
}
#endif

#endif /* RISTRETTO_H */

#endif /* !RISTRETTO_AMALGAMATION */

/* Standard library includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <assert.h>
#include <time.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>


/* BEGIN src/version.c */
/*
** RistrettoDB Version Information
**
** This file contains version information and compilation details
** for the RistrettoDB library.
*/


/*
** Return the version string
*/
const char* ristretto_version(void) {
    return RISTRETTO_VERSION;
}

/*
** Return the version number
*/
int ristretto_version_number(void) {
    return RISTRETTO_VERSION_NUMBER;
}
/* END src/version.c */

/* BEGIN src/util.c */

void* safe_malloc(size_t size) {
    void* ptr = malloc(size);
    if (ptr) {
        memset(ptr, 0, size);
    }
    return ptr;
}

void* safe_realloc(void* ptr, size_t old_size, size_t new_size) {
    void* new_ptr = realloc(ptr, new_size);
    if (new_ptr && new_size > old_size) {
        memset((char*)new_ptr + old_size, 0, new_size - old_size);
    }
    return new_ptr;
}

uint32_t hash_string(const char* str) {
    uint32_t hash = 5381;
    int c;
    
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c;
    }
    
    return hash;
}

char* string_duplicate(const char* str) {
    if (!str) {
        return NULL;
    }
    
    size_t len = strlen(str);
    char* copy = malloc(len + 1);
    if (copy) {
        memcpy(copy, str, len + 1);
    }
    return copy;
}

int string_compare_case_insensitive(const char* a, const char* b) {
    while (*a && *b) {
        int ca = *a;
        int cb = *b;
        
        if (ca >= 'A' && ca <= 'Z') ca += 32;
        if (cb >= 'A' && cb <= 'Z') cb += 32;
        
        if (ca != cb) {
            return ca - cb;
        }
        
        a++;
        b++;
    }
    
    return *a - *b;
}

/* END src/util.c */

/* BEGIN src/pager.c */
/* BEGIN pager.h */
#ifndef RISTRETTO_PAGER_H
#define RISTRETTO_PAGER_H


#define PAGE_SIZE 4096
#define TABLE_MAX_PAGES 1000

typedef struct {
    uint8_t *data;
    size_t file_size;
    int fd;
    void *mapped_memory;
    size_t mapped_size;
} MappedFile;

typedef struct {
    MappedFile *file;
    void *pages[TABLE_MAX_PAGES];
    uint32_t num_pages;
} Pager;

Pager* pager_open(const char *filename);
void pager_close(Pager *pager);

void* pager_get_page(Pager *pager, uint32_t page_num);
void pager_flush_page(Pager *pager, uint32_t page_num);
void pager_sync(Pager *pager);

uint32_t pager_allocate_page(Pager *pager);

#endif

/* END pager.h */

static void ensure_file_size(int fd, size_t min_size) {
    struct stat st;
    if (fstat(fd, &st) == -1) {
        return;
    }
    
    if ((size_t)st.st_size < min_size) {
        if (ftruncate(fd, min_size) == -1) {
            return;
        }
    }
}

static MappedFile* mapped_file_open(const char* filename) {
    MappedFile* file = malloc(sizeof(MappedFile));
    if (!file) {
        return NULL;
    }
    
    file->fd = open(filename, O_RDWR | O_CREAT, 0644);
    if (file->fd == -1) {
        free(file);
        return NULL;
    }
    
    ensure_file_size(file->fd, PAGE_SIZE);
    
    struct stat st;
    if (fstat(file->fd, &st) == -1) {
        close(file->fd);
        free(file);
        return NULL;
    }
    
    file->file_size = st.st_size;
    file->mapped_size = (file->file_size + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    
    file->mapped_memory = mmap(NULL, file->mapped_size, 
                               PROT_READ | PROT_WRITE, 
                               MAP_SHARED, file->fd, 0);
    
    if (file->mapped_memory == MAP_FAILED) {
        close(file->fd);
        free(file);
        return NULL;
    }
    
    file->data = (uint8_t*)file->mapped_memory;
    
    return file;
}

static void mapped_file_close(MappedFile* file) {
    if (!file) {
        return;
    }
    
    if (file->mapped_memory != MAP_FAILED) {
        munmap(file->mapped_memory, file->mapped_size);
    }
    
    if (file->fd != -1) {
        close(file->fd);
    }
    
    free(file);
}

static void mapped_file_resize(MappedFile* file, size_t new_size) {
    if (new_size <= file->mapped_size) {
        file->file_size = new_size;
        return;
    }
    
    munmap(file->mapped_memory, file->mapped_size);
    
    ensure_file_size(file->fd, new_size);
    
    file->file_size = new_size;
    file->mapped_size = (new_size + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    
    file->mapped_memory = mmap(NULL, file->mapped_size,
                               PROT_READ | PROT_WRITE,
                               MAP_SHARED, file->fd, 0);
    
    file->data = (uint8_t*)file->mapped_memory;
}

Pager* pager_open(const char* filename) {
    Pager* pager = malloc(sizeof(Pager));
    if (!pager) {
        return NULL;
    }
    
    pager->file = mapped_file_open(filename);
    if (!pager->file) {
        free(pager);
        return NULL;
    }
    
    memset(pager->pages, 0, sizeof(pager->pages));
    
    pager->num_pages = pager->file->file_size / PAGE_SIZE;
    if (pager->num_pages == 0) {
        pager->num_pages = 1;
    }
    
    return pager;
}

void pager_close(Pager* pager) {
    if (!pager) {
        return;
    }
    
    pager_sync(pager);
    
    mapped_file_close(pager->file);
    free(pager);
}

void* pager_get_page(Pager* pager, uint32_t page_num) {
    if (page_num >= TABLE_MAX_PAGES) {
        return NULL;
    }
    
    if (pager->pages[page_num] == NULL) {
        if (page_num >= pager->num_pages) {
            size_t new_size = (page_num + 1) * PAGE_SIZE;
            mapped_file_resize(pager->file, new_size);
            pager->num_pages = page_num + 1;
        }
        
        size_t offset = page_num * PAGE_SIZE;
        pager->pages[page_num] = pager->file->data + offset;
        
        __builtin_prefetch(pager->pages[page_num], 0, 3);
    }
    
    return pager->pages[page_num];
}

void pager_flush_page(Pager* pager, uint32_t page_num) {
    if (page_num >= pager->num_pages || !pager->pages[page_num]) {
        return;
    }
    
    size_t offset = page_num * PAGE_SIZE;
    msync(pager->file->data + offset, PAGE_SIZE, MS_ASYNC);
}

void pager_sync(Pager* pager) {
    if (!pager || !pager->file) {
        return;
    }
    
    msync(pager->file->mapped_memory, pager->file->mapped_size, MS_SYNC);
}

uint32_t pager_allocate_page(Pager* pager) {
    uint32_t new_page_num = pager->num_pages;
    
    void* page = pager_get_page(pager, new_page_num);
    if (page) {
        memset(page, 0, PAGE_SIZE);
    }
    
    return new_page_num;
}

/* END src/pager.c */

/* BEGIN src/btree.c */
/* BEGIN btree.h */
#ifndef RISTRETTO_BTREE_H
#define RISTRETTO_BTREE_H

/* BEGIN storage.h */
#ifndef RISTRETTO_STORAGE_H
#define RISTRETTO_STORAGE_H


typedef enum {
    TYPE_NULL = 0,
    TYPE_INTEGER = 1,
    TYPE_REAL = 2,
    TYPE_TEXT = 3
} DataType;

typedef struct {
    DataType type;
    union {
        int64_t integer;
        double real;
        struct {
            char *data;
            size_t len;
        } text;
    } value;
} Value;

typedef struct {
    char name[32];
    DataType type;
    size_t offset;
    size_t size;
} Column;

typedef struct {
    char name[64];
    uint32_t column_count;
    Column *columns;
    size_t row_size;
    uint32_t root_page;
    uint32_t row_count;
    uint32_t next_row_id;
} Table;

typedef struct {
    uint32_t page_id;
    uint16_t offset;
} RowId;

typedef struct {
    uint8_t *data;
    size_t size;
} Row;

Table* storage_table_create(const char *name);
void storage_table_destroy(Table *table);

void storage_table_add_column(Table *table, const char *name, DataType type);

Row* storage_row_create(Table *table);
void storage_row_destroy(Row *row);

void storage_row_set_value(Row *row, Table *table, uint32_t col_index, Value *value);
Value* storage_row_get_value(Row *row, Table *table, uint32_t col_index);
void storage_value_destroy(Value *value);

// Table storage operations
RowId table_insert_row(Table *table, Pager *pager, Row *row);
Row* table_get_row(Table *table, Pager *pager, RowId row_id);

// Table scanning
typedef struct {
    Table *table;
    Pager *pager;
    uint32_t current_page;
    uint32_t current_offset;
    uint32_t rows_scanned;
    bool at_end;
} TableScanner;

TableScanner* table_scanner_create(Table *table, Pager *pager);
void table_scanner_destroy(TableScanner *scanner);
Row* table_scanner_next(TableScanner *scanner);
bool table_scanner_at_end(TableScanner *scanner);

#endif

/* END storage.h */

#define BTREE_ORDER 255
#define BTREE_MIN_KEYS ((BTREE_ORDER - 1) / 2)

typedef struct {
    uint32_t page_num;
    bool is_leaf;
    uint32_t num_keys;
    uint32_t parent;
    uint32_t keys[BTREE_ORDER - 1];
    union {
        uint32_t children[BTREE_ORDER];
        RowId values[BTREE_ORDER - 1];
    } ptrs;
} BTreeNode;

typedef struct {
    Pager *pager;
    uint32_t root_page;
    Table *table;
} BTree;

BTree* btree_create(Pager *pager, Table *table);
void btree_destroy(BTree *btree);

bool btree_insert(BTree *btree, uint32_t key, RowId value);
RowId* btree_find(BTree *btree, uint32_t key);

typedef struct {
    BTree *btree;
    uint32_t page_num;
    uint32_t cell_num;
    bool end_of_table;
} BTreeCursor;

BTreeCursor* btree_cursor_create(BTree *btree);
void btree_cursor_destroy(BTreeCursor *cursor);

void btree_cursor_first(BTreeCursor *cursor);
void btree_cursor_advance(BTreeCursor *cursor);
bool btree_cursor_at_end(BTreeCursor *cursor);

uint32_t btree_cursor_key(BTreeCursor *cursor);
RowId btree_cursor_value(BTreeCursor *cursor);

#endif

/* END btree.h */

#define BTREE_NODE_TYPE_LEAF 0x0F
#define BTREE_NODE_TYPE_INTERNAL 0x0E

typedef struct {
    uint8_t node_type;
    uint8_t is_root;
    uint32_t parent_page_num;
    uint32_t num_keys;
} NodeHeader;

static void* get_node(BTree* btree, uint32_t page_num) {
    return pager_get_page(btree->pager, page_num);
}

static NodeHeader* get_node_header(void* node) {
    return (NodeHeader*)node;
}

static uint32_t* get_node_keys(void* node) {
    return (uint32_t*)((uint8_t*)node + sizeof(NodeHeader));
}

static uint32_t* get_internal_node_children(void* node) {
    NodeHeader* header = get_node_header(node);
    return (uint32_t*)((uint8_t*)node + sizeof(NodeHeader) + 
                       sizeof(uint32_t) * (BTREE_ORDER - 1));
}

static RowId* get_leaf_node_values(void* node) {
    return (RowId*)((uint8_t*)node + sizeof(NodeHeader) + 
                    sizeof(uint32_t) * (BTREE_ORDER - 1));
}

static void initialize_node(void* node, bool is_leaf) {
    NodeHeader* header = get_node_header(node);
    header->node_type = is_leaf ? BTREE_NODE_TYPE_LEAF : BTREE_NODE_TYPE_INTERNAL;
    header->is_root = 0;
    header->parent_page_num = 0;
    header->num_keys = 0;
}

static uint32_t find_child_index(void* node, uint32_t key) {
    NodeHeader* header = get_node_header(node);
    uint32_t* keys = get_node_keys(node);
    
    uint32_t left = 0;
    uint32_t right = header->num_keys;
    
    while (left < right) {
        uint32_t mid = (left + right) / 2;
        if (keys[mid] >= key) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}

BTree* btree_create(Pager* pager, Table* table) {
    BTree* btree = malloc(sizeof(BTree));
    if (!btree) {
        return NULL;
    }
    
    btree->pager = pager;
    btree->table = table;
    
    // Create root page
    btree->root_page = pager_allocate_page(pager);
    void* root = get_node(btree, btree->root_page);
    initialize_node(root, true);
    
    NodeHeader* header = get_node_header(root);
    header->is_root = 1;
    
    return btree;
}

void btree_destroy(BTree* btree) {
    free(btree);
}

static bool leaf_node_insert(BTree* btree, void* node, uint32_t key, RowId value) {
    NodeHeader* header = get_node_header(node);
    uint32_t* keys = get_node_keys(node);
    RowId* values = get_leaf_node_values(node);
    
    if (header->num_keys >= BTREE_ORDER - 1) {
        return false; // Node is full
    }
    
    uint32_t index = find_child_index(node, key);
    
    // Check for duplicate key
    if (index < header->num_keys && keys[index] == key) {
        return false;
    }
    
    // Shift keys and values to make room
    if (index < header->num_keys) {
        memmove(&keys[index + 1], &keys[index], 
                sizeof(uint32_t) * (header->num_keys - index));
        memmove(&values[index + 1], &values[index], 
                sizeof(RowId) * (header->num_keys - index));
    }
    
    keys[index] = key;
    values[index] = value;
    header->num_keys++;
    
    return true;
}

bool btree_insert(BTree* btree, uint32_t key, RowId value) {
    void* root = get_node(btree, btree->root_page);
    NodeHeader* header = get_node_header(root);
    
    if (header->node_type == BTREE_NODE_TYPE_LEAF) {
        return leaf_node_insert(btree, root, key, value);
    }
    
    // TODO: Implement internal node traversal and splitting
    return false;
}

static RowId* leaf_node_find(void* node, uint32_t key) {
    NodeHeader* header = get_node_header(node);
    uint32_t* keys = get_node_keys(node);
    RowId* values = get_leaf_node_values(node);
    
    uint32_t index = find_child_index(node, key);
    
    if (index < header->num_keys && keys[index] == key) {
        return &values[index];
    }
    
    return NULL;
}

RowId* btree_find(BTree* btree, uint32_t key) {
    void* root = get_node(btree, btree->root_page);
    NodeHeader* header = get_node_header(root);
    
    if (header->node_type == BTREE_NODE_TYPE_LEAF) {
        return leaf_node_find(root, key);
    }
    
    // TODO: Implement internal node traversal
    return NULL;
}


BTreeCursor* btree_cursor_create(BTree* btree) {
    BTreeCursor* cursor = malloc(sizeof(BTreeCursor));
    if (!cursor) {
        return NULL;
    }
    
    cursor->btree = btree;
    cursor->page_num = btree->root_page;
    cursor->cell_num = 0;
    cursor->end_of_table = false;
    
    return cursor;
}

void btree_cursor_destroy(BTreeCursor* cursor) {
    free(cursor);
}

void btree_cursor_first(BTreeCursor* cursor) {
    cursor->page_num = cursor->btree->root_page;
    cursor->cell_num = 0;
    
    void* node = get_node(cursor->btree, cursor->page_num);
    NodeHeader* header = get_node_header(node);
    
    // Find leftmost leaf
    while (header->node_type == BTREE_NODE_TYPE_INTERNAL) {
        uint32_t* children = get_internal_node_children(node);
        cursor->page_num = children[0];
        node = get_node(cursor->btree, cursor->page_num);
        header = get_node_header(node);
    }
    
    cursor->cell_num = 0;
    cursor->end_of_table = (header->num_keys == 0);
}

void btree_cursor_advance(BTreeCursor* cursor) {
    if (cursor->end_of_table) {
        return;
    }
    
    void* node = get_node(cursor->btree, cursor->page_num);
    NodeHeader* header = get_node_header(node);
    
    cursor->cell_num++;
    
    if (cursor->cell_num >= header->num_keys) {
        // TODO: Move to next leaf node
        cursor->end_of_table = true;
    }
}

bool btree_cursor_at_end(BTreeCursor* cursor) {
    return cursor->end_of_table;
}

uint32_t btree_cursor_key(BTreeCursor* cursor) {
    void* node = get_node(cursor->btree, cursor->page_num);
    uint32_t* keys = get_node_keys(node);
    return keys[cursor->cell_num];
}

RowId btree_cursor_value(BTreeCursor* cursor) {
    void* node = get_node(cursor->btree, cursor->page_num);
    RowId* values = get_leaf_node_values(node);
    return values[cursor->cell_num];
}
/* END src/btree.c */

/* BEGIN src/storage.c */

#define ALIGN_SIZE 8
#define MAX_TEXT_SIZE 255

static size_t get_type_size(DataType type) {
    switch (type) {
        case TYPE_NULL:
            return 0;
        case TYPE_INTEGER:
            return sizeof(int64_t);
        case TYPE_REAL:
            return sizeof(double);
        case TYPE_TEXT:
            return MAX_TEXT_SIZE + 1;
        default:
            return 0;
    }
}

static size_t align_offset(size_t offset) {
    return (offset + ALIGN_SIZE - 1) & ~(ALIGN_SIZE - 1);
}

Table* storage_table_create(const char* name) {
    Table* table = malloc(sizeof(Table));
    if (!table) {
        return NULL;
    }
    
    strncpy(table->name, name, sizeof(table->name) - 1);
    table->name[sizeof(table->name) - 1] = '\0';
    
    table->column_count = 0;
    table->columns = NULL;
    table->row_size = 0;
    table->root_page = 0;
    table->row_count = 0;
    table->next_row_id = 1;
    
    return table;
}

void storage_table_destroy(Table* table) {
    if (!table) {
        return;
    }
    
    free(table->columns);
    free(table);
}

void storage_table_add_column(Table* table, const char* name, DataType type) {
    uint32_t new_count = table->column_count + 1;
    Column* new_columns = realloc(table->columns, new_count * sizeof(Column));
    if (!new_columns) {
        return;
    }
    
    table->columns = new_columns;
    Column* col = &table->columns[table->column_count];
    
    strncpy(col->name, name, sizeof(col->name) - 1);
    col->name[sizeof(col->name) - 1] = '\0';
    
    col->type = type;
    col->size = get_type_size(type);
    col->offset = align_offset(table->row_size);
    
    table->row_size = col->offset + col->size;
    table->column_count = new_count;
}

Row* storage_row_create(Table* table) {
    Row* row = malloc(sizeof(Row));
    if (!row) {
        return NULL;
    }
    
    row->size = table->row_size;
    row->data = calloc(1, row->size);
    if (!row->data) {
        free(row);
        return NULL;
    }
    
    return row;
}

void storage_row_destroy(Row* row) {
    if (!row) {
        return;
    }
    
    free(row->data);
    free(row);
}

void storage_row_set_value(Row* row, Table* table, uint32_t col_index, Value* value) {
    if (col_index >= table->column_count) {
        return;
    }
    
    Column* col = &table->columns[col_index];
    uint8_t* dest = row->data + col->offset;
    
    switch (col->type) {
        case TYPE_NULL:
            break;
            
        case TYPE_INTEGER:
            if (value->type == TYPE_INTEGER) {
                memcpy(dest, &value->value.integer, sizeof(int64_t));
            }
            break;
            
        case TYPE_REAL:
            if (value->type == TYPE_REAL) {
                memcpy(dest, &value->value.real, sizeof(double));
            }
            break;
            
        case TYPE_TEXT:
            if (value->type == TYPE_TEXT && value->value.text.data) {
                size_t copy_len = value->value.text.len;
                if (copy_len > MAX_TEXT_SIZE) {
                    copy_len = MAX_TEXT_SIZE;
                }
                memcpy(dest, value->value.text.data, copy_len);
                dest[copy_len] = '\0';
            }
            break;
    }
}

Value* storage_row_get_value(Row* row, Table* table, uint32_t col_index) {
    if (col_index >= table->column_count) {
        return NULL;
    }
    
    Value* value = malloc(sizeof(Value));
    if (!value) {
        return NULL;
    }
    
    Column* col = &table->columns[col_index];
    uint8_t* src = row->data + col->offset;
    
    value->type = col->type;
    
    switch (col->type) {
        case TYPE_NULL:
            break;
            
        case TYPE_INTEGER:
            memcpy(&value->value.integer, src, sizeof(int64_t));
            break;
            
        case TYPE_REAL:
            memcpy(&value->value.real, src, sizeof(double));
            break;
            
        case TYPE_TEXT:
            value->value.text.len = strlen((char*)src);
            value->value.text.data = malloc(value->value.text.len + 1);
            if (value->value.text.data) {
                strcpy(value->value.text.data, (char*)src);
            }
            break;
    }
    
    return value;
}

void storage_value_destroy(Value* value) {
    if (!value) {
        return;
    }
    
    if (value->type == TYPE_TEXT && value->value.text.data) {
        free(value->value.text.data);
    }
    
    free(value);
}

// Page layout:
// [page_header: 8 bytes][row_slots: variable]
typedef struct {
    uint32_t page_type;      // 0 = data page
    uint32_t row_count;      // number of rows in this page
} PageHeader;

#define ROWS_PER_PAGE ((PAGE_SIZE - sizeof(PageHeader)) / sizeof(uint32_t))

RowId table_insert_row(Table *table, Pager *pager, Row *row) {
    // Simple implementation: always append to the last page
    if (table->root_page == 0) {
        table->root_page = pager_allocate_page(pager);
        void* page = pager_get_page(pager, table->root_page);
        PageHeader* header = (PageHeader*)page;
        header->page_type = 0;
        header->row_count = 0;
    }
    
    void* page = pager_get_page(pager, table->root_page);
    PageHeader* header = (PageHeader*)page;
    
    // Check if page has space
    if (header->row_count * table->row_size + sizeof(PageHeader) + table->row_size > PAGE_SIZE) {
        // TODO: Allocate new page or use B+tree
        return (RowId){0, 0}; // Out of space
    }
    
    // Copy row data to page
    uint8_t* row_data = (uint8_t*)page + sizeof(PageHeader) + header->row_count * table->row_size;
    memcpy(row_data, row->data, table->row_size);
    
    RowId row_id = {table->root_page, (uint16_t)(header->row_count * table->row_size + sizeof(PageHeader))};
    header->row_count++;
    table->row_count++;
    
    return row_id;
}

Row* table_get_row(Table *table, Pager *pager, RowId row_id) {
    void* page = pager_get_page(pager, row_id.page_id);
    if (!page) return NULL;
    
    uint8_t* row_data = (uint8_t*)page + row_id.offset;
    
    Row* row = malloc(sizeof(Row));
    if (!row) return NULL;
    
    row->size = table->row_size;
    row->data = malloc(table->row_size);
    if (!row->data) {
        free(row);
        return NULL;
    }
    
    memcpy(row->data, row_data, table->row_size);
    return row;
}


TableScanner* table_scanner_create(Table *table, Pager *pager) {
    TableScanner* scanner = malloc(sizeof(TableScanner));
    if (!scanner) return NULL;
    
    scanner->table = table;
    scanner->pager = pager;
    scanner->current_page = table->root_page;
    scanner->current_offset = sizeof(PageHeader);
    scanner->rows_scanned = 0;
    scanner->at_end = (table->row_count == 0);
    
    return scanner;
}

void table_scanner_destroy(TableScanner *scanner) {
    free(scanner);
}

Row* table_scanner_next(TableScanner *scanner) {
    if (scanner->at_end || scanner->rows_scanned >= scanner->table->row_count) {
        scanner->at_end = true;
        return NULL;
    }
    
    void* page = pager_get_page(scanner->pager, scanner->current_page);
    if (!page) {
        scanner->at_end = true;
        return NULL;
    }
    
    PageHeader* header = (PageHeader*)page;
    uint32_t row_index = (scanner->current_offset - sizeof(PageHeader)) / scanner->table->row_size;
    
    if (row_index >= header->row_count) {
        // TODO: Move to next page
        scanner->at_end = true;
        return NULL;
    }
    
    uint8_t* row_data = (uint8_t*)page + scanner->current_offset;
    
    Row* row = malloc(sizeof(Row));
    if (!row) return NULL;
    
    row->size = scanner->table->row_size;
    row->data = malloc(scanner->table->row_size);
    if (!row->data) {
        free(row);
        return NULL;
    }
    
    memcpy(row->data, row_data, scanner->table->row_size);
    
    // Advance to next row
    scanner->current_offset += scanner->table->row_size;
    scanner->rows_scanned++;
    
    return row;
}

bool table_scanner_at_end(TableScanner *scanner) {
    return scanner->at_end;
}

/* END src/storage.c */

/* BEGIN src/simd.c */
/* BEGIN simd.h */
#ifndef RISTRETTO_SIMD_H
#define RISTRETTO_SIMD_H


#ifdef __clang__
typedef int32_t v4i __attribute__((vector_size(16)));
typedef int64_t v2i64 __attribute__((vector_size(16)));
typedef float v4f __attribute__((vector_size(16)));
typedef double v2d __attribute__((vector_size(16)));
#endif

void simd_filter_eq_i32(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap);
void simd_filter_gt_i32(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap);
void simd_filter_lt_i32(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap);

void simd_filter_eq_i64(const int64_t *column, size_t count, int64_t value, uint8_t *bitmap);
void simd_filter_gt_i64(const int64_t *column, size_t count, int64_t value, uint8_t *bitmap);
void simd_filter_lt_i64(const int64_t *column, size_t count, int64_t value, uint8_t *bitmap);

void simd_filter_eq_f64(const double *column, size_t count, double value, uint8_t *bitmap);
void simd_filter_gt_f64(const double *column, size_t count, double value, uint8_t *bitmap);
void simd_filter_lt_f64(const double *column, size_t count, double value, uint8_t *bitmap);

void simd_bitmap_and(const uint8_t *a, const uint8_t *b, uint8_t *result, size_t count);
void simd_bitmap_or(const uint8_t *a, const uint8_t *b, uint8_t *result, size_t count);

size_t simd_count_set_bits(const uint8_t *bitmap, size_t count);

#endif

/* END simd.h */

// Basic scalar implementations
void simd_filter_eq_i32(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] == value) ? 1 : 0;
    }
}

void simd_filter_gt_i32(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] > value) ? 1 : 0;
    }
}

void simd_filter_lt_i32(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] < value) ? 1 : 0;
    }
}

void simd_filter_eq_i64(const int64_t *column, size_t count, int64_t value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] == value) ? 1 : 0;
    }
}

void simd_filter_gt_i64(const int64_t *column, size_t count, int64_t value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] > value) ? 1 : 0;
    }
}

void simd_filter_lt_i64(const int64_t *column, size_t count, int64_t value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] < value) ? 1 : 0;
    }
}

void simd_filter_eq_f64(const double *column, size_t count, double value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] == value) ? 1 : 0;
    }
}

void simd_filter_gt_f64(const double *column, size_t count, double value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] > value) ? 1 : 0;
    }
}

void simd_filter_lt_f64(const double *column, size_t count, double value, uint8_t *bitmap) {
    for (size_t i = 0; i < count; i++) {
        bitmap[i] = (column[i] < value) ? 1 : 0;
    }
}

void simd_bitmap_and(const uint8_t *a, const uint8_t *b, uint8_t *result, size_t count) {
    for (size_t i = 0; i < count; i++) {
        result[i] = a[i] & b[i];
    }
}

void simd_bitmap_or(const uint8_t *a, const uint8_t *b, uint8_t *result, size_t count) {
    for (size_t i = 0; i < count; i++) {
        result[i] = a[i] | b[i];
    }
}

size_t simd_count_set_bits(const uint8_t *bitmap, size_t count) {
    size_t total = 0;
    for (size_t i = 0; i < count; i++) {
        total += bitmap[i] ? 1 : 0;
    }
    return total;
}

#ifdef __clang__
// SIMD optimized versions using Clang vector extensions

void simd_filter_eq_i32_vectorized(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap) {
    size_t vector_count = count / 4;
    size_t remainder = count % 4;
    
    v4i target = {value, value, value, value};
    
    for (size_t i = 0; i < vector_count; i++) {
        v4i vals = *((v4i*)&column[i * 4]);
        v4i cmp = vals == target;
        
        // Extract results
        bitmap[i * 4 + 0] = cmp[0] ? 1 : 0;
        bitmap[i * 4 + 1] = cmp[1] ? 1 : 0;
        bitmap[i * 4 + 2] = cmp[2] ? 1 : 0;
        bitmap[i * 4 + 3] = cmp[3] ? 1 : 0;
        
        // Prefetch next cache line
        if (i + 4 < vector_count) {
            __builtin_prefetch(&column[(i + 4) * 4], 0, 3);
        }
    }
    
    // Handle remainder
    for (size_t i = vector_count * 4; i < count; i++) {
        bitmap[i] = (column[i] == value) ? 1 : 0;
    }
}

void simd_filter_gt_i32_vectorized(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap) {
    size_t vector_count = count / 4;
    size_t remainder = count % 4;
    
    v4i target = {value, value, value, value};
    
    for (size_t i = 0; i < vector_count; i++) {
        v4i vals = *((v4i*)&column[i * 4]);
        v4i cmp = vals > target;
        
        bitmap[i * 4 + 0] = cmp[0] ? 1 : 0;
        bitmap[i * 4 + 1] = cmp[1] ? 1 : 0;
        bitmap[i * 4 + 2] = cmp[2] ? 1 : 0;
        bitmap[i * 4 + 3] = cmp[3] ? 1 : 0;
        
        if (i + 4 < vector_count) {
            __builtin_prefetch(&column[(i + 4) * 4], 0, 3);
        }
    }
    
    for (size_t i = vector_count * 4; i < count; i++) {
        bitmap[i] = (column[i] > value) ? 1 : 0;
    }
}

void simd_filter_eq_f64_vectorized(const double *column, size_t count, double value, uint8_t *bitmap) {
    size_t vector_count = count / 2;
    
    v2d target = {value, value};
    
    for (size_t i = 0; i < vector_count; i++) {
        v2d vals = *((v2d*)&column[i * 2]);
        v2d cmp = vals == target;
        
        bitmap[i * 2 + 0] = cmp[0] ? 1 : 0;
        bitmap[i * 2 + 1] = cmp[1] ? 1 : 0;
        
        if (i + 4 < vector_count) {
            __builtin_prefetch(&column[(i + 4) * 2], 0, 3);
        }
    }
    
    for (size_t i = vector_count * 2; i < count; i++) {
        bitmap[i] = (column[i] == value) ? 1 : 0;
    }
}

// Use vectorized versions by default on supported platforms
void simd_filter_eq_i32_fast(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap) {
    if (count >= 16) {
        simd_filter_eq_i32_vectorized(column, count, value, bitmap);
    } else {
        simd_filter_eq_i32(column, count, value, bitmap);
    }
}

void simd_filter_gt_i32_fast(const int32_t *column, size_t count, int32_t value, uint8_t *bitmap) {
    if (count >= 16) {
        simd_filter_gt_i32_vectorized(column, count, value, bitmap);
    } else {
        simd_filter_gt_i32(column, count, value, bitmap);
    }
}

#endif
/* END src/simd.c */

/* BEGIN src/table_v2.c */
/* BEGIN table_v2.h */
#ifndef RISTRETTO_TABLE_V2_H
#define RISTRETTO_TABLE_V2_H


#define MAX_COLUMNS 14
#define MAX_COLUMN_NAME 8
#define TABLE_HEADER_SIZE 256
#define INITIAL_FILE_SIZE (1024 * 1024)  // 1 MB initial size
#define GROWTH_FACTOR 2                   // Double size when growing
#define SYNC_INTERVAL_ROWS 512           // Sync every N rows
#define SYNC_INTERVAL_MS 100             // Sync every N milliseconds

// Magic bytes for file format identification
#define TABLE_MAGIC "RSTRDB\x00\x00"
#define TABLE_VERSION 1

typedef enum {
    COL_TYPE_INTEGER = 1,
    COL_TYPE_REAL = 2,
    COL_TYPE_TEXT = 3,
    COL_TYPE_NULLABLE = 4
} ColumnType;

typedef struct {
    char name[MAX_COLUMN_NAME];  // Column name (truncated/padded)
    uint8_t type;                // ColumnType
    uint8_t length;              // Bytes if TEXT, 0 for INTEGER/REAL
    uint16_t offset;             // Byte offset within row
    uint8_t reserved[4];         // Padding/reserved for future use
} ColumnDesc;

typedef struct {
    char magic[8];               // "RSTRDB\x00\x00"
    uint32_t version;            // File format version
    uint32_t row_size;           // Size in bytes of a single row
    uint64_t num_rows;           // Number of rows written
    uint32_t column_count;       // Number of columns
    uint8_t reserved[12];        // Reserved for future use
    ColumnDesc columns[MAX_COLUMNS];  // Column descriptors (224 bytes)
} TableHeader;

typedef struct {
    char name[64];               // Table name
    int fd;                      // File descriptor
    uint8_t *mapped_ptr;         // Memory-mapped file pointer
    size_t mapped_size;          // Current mapped size
    size_t write_offset;         // Current write position
    TableHeader *header;         // Pointer to header in mapped memory
    
    // Performance tracking
    uint64_t rows_since_sync;    // Rows written since last sync
    uint64_t last_sync_time_ms;  // Last sync timestamp
    
    // File path for remapping
    char file_path[256];
} Table;

typedef struct {
    ColumnType type;
    union {
        int64_t integer;
        double real;
        struct {
            char *data;
            size_t length;
        } text;
    } value;
    bool is_null;
} Value;

// Table lifecycle functions
Table* table_create(const char *name, const char *schema_sql);
Table* table_open(const char *name);
void table_close(Table *table);

// Core operations
bool table_append_row(Table *table, const Value *values);
bool table_select(Table *table, const char *where_clause, 
                 void (*callback)(void *ctx, const Value *row), void *ctx);

// File management
bool table_flush(Table *table);
bool table_remap(Table *table);
bool table_ensure_space(Table *table, size_t needed_bytes);

// Schema and metadata
bool table_parse_schema(const char *schema_sql, ColumnDesc *columns, 
                       uint32_t *column_count, uint32_t *row_size);
const ColumnDesc* table_get_column(Table *table, const char *name);
size_t table_get_row_count(Table *table);

// Value utilities
Value value_integer(int64_t val);
Value value_real(double val);
Value value_text(const char *str);
Value value_null(void);
void value_destroy(Value *value);

// Row packing/unpacking
bool table_pack_row(Table *table, const Value *values, uint8_t *row_buffer);
bool table_unpack_row(Table *table, const uint8_t *row_buffer, Value *values);

// Utility functions
uint64_t get_time_ms(void);
bool create_data_directory(void);

#endif

/* END table_v2.h */

// Utility functions
uint64_t get_time_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
}

bool create_data_directory(void) {
    struct stat st = {0};
    if (stat("data", &st) == -1) {
        return mkdir("data", 0755) == 0;
    }
    return true;
}

// Value constructors
Value value_integer(int64_t val) {
    Value v = {0};
    v.type = COL_TYPE_INTEGER;
    v.value.integer = val;
    v.is_null = false;
    return v;
}

Value value_real(double val) {
    Value v = {0};
    v.type = COL_TYPE_REAL;
    v.value.real = val;
    v.is_null = false;
    return v;
}

Value value_text(const char *str) {
    Value v = {0};
    v.type = COL_TYPE_TEXT;
    if (str) {
        size_t len = strlen(str);
        v.value.text.data = malloc(len + 1);
        if (v.value.text.data) {
            strcpy(v.value.text.data, str);
            v.value.text.length = len;
        }
    }
    v.is_null = (str == NULL);
    return v;
}

Value value_null(void) {
    Value v = {0};
    v.is_null = true;
    return v;
}

void value_destroy(Value *value) {
    if (value && value->type == COL_TYPE_TEXT && value->value.text.data) {
        free(value->value.text.data);
        value->value.text.data = NULL;
        value->value.text.length = 0;
    }
}

// Schema parsing (simplified - will need full parser integration later)
bool table_parse_schema(const char *schema_sql, ColumnDesc *columns, 
                       uint32_t *column_count, uint32_t *row_size) {
    // Simple parser for basic CREATE TABLE statements
    // Format: CREATE TABLE name (col1 TYPE, col2 TYPE(size), ...)
    
    *column_count = 0;
    *row_size = 0;
    
    // Find the opening parenthesis
    const char *start = strchr(schema_sql, '(');
    if (!start) return false;
    start++;
    
    const char *end = strrchr(schema_sql, ')');
    if (!end) return false;
    
    // Parse column definitions
    char col_def[256];
    const char *current = start;
    uint32_t offset = 0;
    
    while (current < end && *column_count < MAX_COLUMNS) {
        // Extract column definition
        const char *comma = strchr(current, ',');
        if (!comma) comma = end;
        
        size_t def_len = comma - current;
        if (def_len >= sizeof(col_def)) def_len = sizeof(col_def) - 1;
        
        strncpy(col_def, current, def_len);
        col_def[def_len] = '\0';
        
        // Parse column name and type
        char name[MAX_COLUMN_NAME] = {0};
        char type_str[32] = {0};
        int length = 0;
        
        if (sscanf(col_def, " %31s %31s", name, type_str) < 2) {
            break;
        }
        
        // Determine column type and size
        ColumnDesc *col = &columns[*column_count];
        strncpy(col->name, name, MAX_COLUMN_NAME - 1);
        col->offset = offset;
        
        if (strncmp(type_str, "INTEGER", 7) == 0) {
            col->type = COL_TYPE_INTEGER;
            col->length = 8;
        } else if (strncmp(type_str, "REAL", 4) == 0) {
            col->type = COL_TYPE_REAL;
            col->length = 8;
        } else if (strncmp(type_str, "TEXT", 4) == 0) {
            col->type = COL_TYPE_TEXT;
            // Parse TEXT(n) format
            if (sscanf(type_str, "TEXT(%d)", &length) == 1) {
                col->length = (length > 255) ? 255 : length;
            } else {
                col->length = 64; // Default text size
            }
        } else {
            return false; // Unsupported type
        }
        
        offset += col->length;
        (*column_count)++;
        
        current = comma + 1;
        if (comma == end) break;
    }
    
    *row_size = offset;
    return *column_count > 0;
}

// Table creation
Table* table_create(const char *name, const char *schema_sql) {
    if (!create_data_directory()) {
        return NULL;
    }
    
    Table *table = calloc(1, sizeof(Table));
    if (!table) return NULL;
    
    // Parse schema into temporary variables
    ColumnDesc temp_columns[MAX_COLUMNS];
    uint32_t temp_column_count, temp_row_size;
    if (!table_parse_schema(schema_sql, temp_columns, &temp_column_count, &temp_row_size)) {
        free(table);
        return NULL;
    }
    
    // Create file path
    snprintf(table->file_path, sizeof(table->file_path), "data/%s.rdb", name);
    strncpy(table->name, name, sizeof(table->name) - 1);
    
    // Create and open file
    table->fd = open(table->file_path, O_CREAT | O_RDWR | O_TRUNC, 0644);
    if (table->fd == -1) {
        free(table);
        return NULL;
    }
    
    // Set initial file size
    if (ftruncate(table->fd, INITIAL_FILE_SIZE) == -1) {
        close(table->fd);
        free(table);
        return NULL;
    }
    
    // Memory map the file
    table->mapped_ptr = mmap(NULL, INITIAL_FILE_SIZE, PROT_READ | PROT_WRITE, 
                            MAP_SHARED, table->fd, 0);
    if (table->mapped_ptr == MAP_FAILED) {
        close(table->fd);
        free(table);
        return NULL;
    }
    
    table->mapped_size = INITIAL_FILE_SIZE;
    table->header = (TableHeader*)table->mapped_ptr;
    table->write_offset = TABLE_HEADER_SIZE;
    
    // Initialize header
    memcpy(table->header->magic, TABLE_MAGIC, 8);
    table->header->version = TABLE_VERSION;
    table->header->num_rows = 0;
    
    // Copy parsed schema to header
    table->header->column_count = temp_column_count;
    table->header->row_size = temp_row_size;
    memcpy(table->header->columns, temp_columns, sizeof(ColumnDesc) * temp_column_count);
    
    table->rows_since_sync = 0;
    table->last_sync_time_ms = get_time_ms();
    
    return table;
}

// Table opening
Table* table_open(const char *name) {
    Table *table = calloc(1, sizeof(Table));
    if (!table) return NULL;
    
    // Create file path
    snprintf(table->file_path, sizeof(table->file_path), "data/%s.rdb", name);
    strncpy(table->name, name, sizeof(table->name) - 1);
    
    // Open existing file
    table->fd = open(table->file_path, O_RDWR);
    if (table->fd == -1) {
        free(table);
        return NULL;
    }
    
    // Get file size
    struct stat st;
    if (fstat(table->fd, &st) == -1) {
        close(table->fd);
        free(table);
        return NULL;
    }
    
    if (st.st_size < TABLE_HEADER_SIZE) {
        close(table->fd);
        free(table);
        return NULL;
    }
    
    // Memory map the file
    table->mapped_ptr = mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, 
                            MAP_SHARED, table->fd, 0);
    if (table->mapped_ptr == MAP_FAILED) {
        close(table->fd);
        free(table);
        return NULL;
    }
    
    table->mapped_size = st.st_size;
    table->header = (TableHeader*)table->mapped_ptr;
    
    // Validate header
    if (memcmp(table->header->magic, TABLE_MAGIC, 8) != 0 ||
        table->header->version != TABLE_VERSION) {
        munmap(table->mapped_ptr, table->mapped_size);
        close(table->fd);
        free(table);
        return NULL;
    }
    
    // Calculate write offset
    table->write_offset = TABLE_HEADER_SIZE + (table->header->num_rows * table->header->row_size);
    table->rows_since_sync = 0;
    table->last_sync_time_ms = get_time_ms();
    
    return table;
}

// Table closing
void table_close(Table *table) {
    if (!table) return;
    
    table_flush(table);
    
    if (table->mapped_ptr && table->mapped_ptr != MAP_FAILED) {
        munmap(table->mapped_ptr, table->mapped_size);
    }
    
    if (table->fd != -1) {
        close(table->fd);
    }
    
    free(table);
}

// File growth and remapping
bool table_ensure_space(Table *table, size_t needed_bytes) {
    if (table->write_offset + needed_bytes <= table->mapped_size) {
        return true; // Already have enough space
    }
    
    return table_remap(table);
}

bool table_remap(Table *table) {
    size_t new_size = table->mapped_size * GROWTH_FACTOR;
    
    // Unmap current mapping
    if (munmap(table->mapped_ptr, table->mapped_size) == -1) {
        return false;
    }
    
    // Resize file
    if (ftruncate(table->fd, new_size) == -1) {
        return false;
    }
    
    // Remap with new size
    table->mapped_ptr = mmap(NULL, new_size, PROT_READ | PROT_WRITE, 
                            MAP_SHARED, table->fd, 0);
    if (table->mapped_ptr == MAP_FAILED) {
        return false;
    }
    
    table->mapped_size = new_size;
    table->header = (TableHeader*)table->mapped_ptr;
    
    return true;
}

// Row packing
bool table_pack_row(Table *table, const Value *values, uint8_t *row_buffer) {
    memset(row_buffer, 0, table->header->row_size);
    
    for (uint32_t i = 0; i < table->header->column_count; i++) {
        const ColumnDesc *col = &table->header->columns[i];
        const Value *val = &values[i];
        uint8_t *dest = row_buffer + col->offset;
        
        if (val->is_null) {
            // For now, just write zeros for NULL values
            continue;
        }
        
        switch (col->type) {
            case COL_TYPE_INTEGER:
                *(int64_t*)dest = val->value.integer;
                break;
                
            case COL_TYPE_REAL:
                *(double*)dest = val->value.real;
                break;
                
            case COL_TYPE_TEXT:
                if (val->value.text.data) {
                    size_t copy_len = val->value.text.length;
                    if (copy_len > col->length - 1) {
                        copy_len = col->length - 1;
                    }
                    memcpy(dest, val->value.text.data, copy_len);
                    dest[copy_len] = '\0';
                }
                break;
                
            default:
                return false;
        }
    }
    
    return true;
}

// Row unpacking
bool table_unpack_row(Table *table, const uint8_t *row_buffer, Value *values) {
    for (uint32_t i = 0; i < table->header->column_count; i++) {
        const ColumnDesc *col = &table->header->columns[i];
        const uint8_t *src = row_buffer + col->offset;
        Value *val = &values[i];
        
        val->type = col->type;
        val->is_null = false;
        
        switch (col->type) {
            case COL_TYPE_INTEGER:
                val->value.integer = *(int64_t*)src;
                break;
                
            case COL_TYPE_REAL:
                val->value.real = *(double*)src;
                break;
                
            case COL_TYPE_TEXT:
                val->value.text.length = strnlen((char*)src, col->length);
                val->value.text.data = malloc(val->value.text.length + 1);
                if (val->value.text.data) {
                    memcpy(val->value.text.data, src, val->value.text.length);
                    val->value.text.data[val->value.text.length] = '\0';
                } else {
                    return false;
                }
                break;
                
            default:
                return false;
        }
    }
    
    return true;
}

// Ultra-fast row insertion
bool table_append_row(Table *table, const Value *values) {
    if (!table || !values) return false;
    
    // Ensure we have space for the row
    if (!table_ensure_space(table, table->header->row_size)) {
        return false;
    }
    
    // Pack row directly into mapped memory
    uint8_t *row_dest = table->mapped_ptr + table->write_offset;
    if (!table_pack_row(table, values, row_dest)) {
        return false;
    }
    
    // Update write position and row count
    table->write_offset += table->header->row_size;
    table->header->num_rows++;
    table->rows_since_sync++;
    
    // Check if we should sync
    uint64_t current_time = get_time_ms();
    if (table->rows_since_sync >= SYNC_INTERVAL_ROWS ||
        (current_time - table->last_sync_time_ms) >= SYNC_INTERVAL_MS) {
        table_flush(table);
    }
    
    return true;
}

// Sync and durability
bool table_flush(Table *table) {
    if (!table || !table->mapped_ptr) return false;
    
    // Sync memory-mapped region
    if (msync(table->mapped_ptr, table->write_offset, MS_ASYNC) == -1) {
        return false;
    }
    
    table->rows_since_sync = 0;
    table->last_sync_time_ms = get_time_ms();
    
    return true;
}

// Table scanning and selection
bool table_select(Table *table, const char *where_clause, 
                 void (*callback)(void *ctx, const Value *row), void *ctx) {
    if (!table || !callback) return false;
    
    (void)where_clause; // TODO: Implement WHERE clause parsing
    
    Value *row_values = malloc(sizeof(Value) * table->header->column_count);
    if (!row_values) return false;
    
    uint8_t *current_row = table->mapped_ptr + TABLE_HEADER_SIZE;
    
    for (uint64_t i = 0; i < table->header->num_rows; i++) {
        if (table_unpack_row(table, current_row, row_values)) {
            callback(ctx, row_values);
            
            // Clean up text values
            for (uint32_t j = 0; j < table->header->column_count; j++) {
                value_destroy(&row_values[j]);
            }
        }
        
        current_row += table->header->row_size;
    }
    
    free(row_values);
    return true;
}

// Utility functions
const ColumnDesc* table_get_column(Table *table, const char *name) {
    if (!table || !name) return NULL;
    
    for (uint32_t i = 0; i < table->header->column_count; i++) {
        if (strncmp(table->header->columns[i].name, name, MAX_COLUMN_NAME) == 0) {
            return &table->header->columns[i];
        }
    }
    
    return NULL;
}

size_t table_get_row_count(Table *table) {
    return table ? table->header->num_rows : 0;
}

/* END src/table_v2.c */

/* BEGIN src/parser.c */
/* BEGIN parser.h */
#ifndef RISTRETTO_PARSER_H
#define RISTRETTO_PARSER_H


typedef enum {
    STMT_CREATE_TABLE,
    STMT_INSERT,
    STMT_SELECT
} StatementType;

typedef enum {
    EXPR_LITERAL,
    EXPR_COLUMN,
    EXPR_BINARY_OP
} ExprType;

typedef enum {
    OP_EQ,
    OP_NE,
    OP_LT,
    OP_LE,
    OP_GT,
    OP_GE,
    OP_AND,
    OP_OR
} BinaryOp;

typedef struct Expr {
    ExprType type;
    union {
        Value literal;
        struct {
            char *table;
            char *column;
        } column;
        struct {
            BinaryOp op;
            struct Expr *left;
            struct Expr *right;
        } binary;
    } data;
} Expr;

typedef struct {
    char *table_name;
    uint32_t column_count;
    struct {
        char *name;
        DataType type;
    } *columns;
} CreateTableStmt;

typedef struct {
    char *table_name;
    uint32_t value_count;
    Value *values;
} InsertStmt;

typedef struct {
    char *table_name;
    uint32_t column_count;
    char **columns;
    Expr *where_clause;
} SelectStmt;


typedef struct {
    StatementType type;
    union {
        CreateTableStmt create_table;
        InsertStmt insert;
        SelectStmt select;
    } data;
} Statement;

Statement* parse_sql(const char *sql);
void statement_destroy(Statement *stmt);

void expr_destroy(Expr *expr);

#endif

/* END parser.h */

typedef struct {
    const char* start;
    const char* current;
    size_t length;
} Scanner;

static void scanner_init(Scanner* scanner, const char* sql) {
    scanner->start = sql;
    scanner->current = sql;
    scanner->length = strlen(sql);
}

static bool is_at_end(Scanner* scanner) {
    return scanner->current >= scanner->start + scanner->length;
}

static char peek(Scanner* scanner) {
    if (is_at_end(scanner)) return '\0';
    return *scanner->current;
}

static char advance(Scanner* scanner) {
    if (is_at_end(scanner)) return '\0';
    return *scanner->current++;
}

static void skip_whitespace(Scanner* scanner) {
    while (!is_at_end(scanner)) {
        char c = peek(scanner);
        if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
            advance(scanner);
        } else {
            break;
        }
    }
}

static bool match_keyword(Scanner* scanner, const char* keyword) {
    skip_whitespace(scanner);
    const char* saved = scanner->current;
    size_t len = strlen(keyword);
    
    for (size_t i = 0; i < len; i++) {
        if (toupper(advance(scanner)) != toupper(keyword[i])) {
            scanner->current = saved;
            return false;
        }
    }
    
    // Ensure keyword ends with non-alpha character
    if (isalpha(peek(scanner))) {
        scanner->current = saved;
        return false;
    }
    
    return true;
}

static char* parse_identifier(Scanner* scanner) {
    skip_whitespace(scanner);
    const char* start = scanner->current;
    
    if (!isalpha(peek(scanner)) && peek(scanner) != '_') {
        return NULL;
    }
    
    while (isalnum(peek(scanner)) || peek(scanner) == '_') {
        advance(scanner);
    }
    
    size_t len = scanner->current - start;
    char* identifier = malloc(len + 1);
    if (identifier) {
        memcpy(identifier, start, len);
        identifier[len] = '\0';
    }
    
    return identifier;
}

static Value* parse_value(Scanner* scanner) {
    skip_whitespace(scanner);
    Value* value = malloc(sizeof(Value));
    if (!value) return NULL;
    
    char c = peek(scanner);
    
    // Parse string literal
    if (c == '\'' || c == '"') {
        char quote = advance(scanner);
        const char* start = scanner->current;
        
        while (peek(scanner) != quote && !is_at_end(scanner)) {
            advance(scanner);
        }
        
        size_t len = scanner->current - start;
        value->type = TYPE_TEXT;
        value->value.text.len = len;
        value->value.text.data = malloc(len + 1);
        if (value->value.text.data) {
            memcpy(value->value.text.data, start, len);
            value->value.text.data[len] = '\0';
        }
        
        advance(scanner); // Skip closing quote
        return value;
    }
    
    // Parse number
    if (isdigit(c) || c == '-' || c == '+') {
        const char* start = scanner->current;
        bool has_decimal = false;
        
        if (c == '-' || c == '+') advance(scanner);
        
        while (isdigit(peek(scanner))) {
            advance(scanner);
        }
        
        if (peek(scanner) == '.') {
            has_decimal = true;
            advance(scanner);
            while (isdigit(peek(scanner))) {
                advance(scanner);
            }
        }
        
        char* end;
        if (has_decimal) {
            value->type = TYPE_REAL;
            value->value.real = strtod(start, &end);
        } else {
            value->type = TYPE_INTEGER;
            value->value.integer = strtoll(start, &end, 10);
        }
        
        return value;
    }
    
    // Parse NULL
    if (match_keyword(scanner, "NULL")) {
        value->type = TYPE_NULL;
        return value;
    }
    
    free(value);
    return NULL;
}

static DataType parse_type(Scanner* scanner) {
    skip_whitespace(scanner);
    
    if (match_keyword(scanner, "INTEGER") || match_keyword(scanner, "INT")) {
        return TYPE_INTEGER;
    } else if (match_keyword(scanner, "REAL") || match_keyword(scanner, "FLOAT") || 
               match_keyword(scanner, "DOUBLE")) {
        return TYPE_REAL;
    } else if (match_keyword(scanner, "TEXT") || match_keyword(scanner, "VARCHAR")) {
        return TYPE_TEXT;
    }
    
    return TYPE_NULL;
}

static bool expect_char(Scanner* scanner, char expected) {
    skip_whitespace(scanner);
    if (peek(scanner) == expected) {
        advance(scanner);
        return true;
    }
    return false;
}

static Statement* parse_create_table(Scanner* scanner) {
    Statement* stmt = malloc(sizeof(Statement));
    if (!stmt) return NULL;
    
    stmt->type = STMT_CREATE_TABLE;
    stmt->data.create_table.table_name = parse_identifier(scanner);
    if (!stmt->data.create_table.table_name) {
        free(stmt);
        return NULL;
    }
    
    if (!expect_char(scanner, '(')) {
        free(stmt->data.create_table.table_name);
        free(stmt);
        return NULL;
    }
    
    // Parse columns
    stmt->data.create_table.columns = NULL;
    stmt->data.create_table.column_count = 0;
    size_t capacity = 0;
    
    do {
        if (stmt->data.create_table.column_count >= capacity) {
            capacity = capacity ? capacity * 2 : 4;
            void* new_cols = realloc(stmt->data.create_table.columns,
                                     capacity * sizeof(stmt->data.create_table.columns[0]));
            if (!new_cols) {
                statement_destroy(stmt);
                return NULL;
            }
            stmt->data.create_table.columns = new_cols;
        }
        
        size_t idx = stmt->data.create_table.column_count;
        stmt->data.create_table.columns[idx].name = parse_identifier(scanner);
        if (!stmt->data.create_table.columns[idx].name) {
            statement_destroy(stmt);
            return NULL;
        }
        
        stmt->data.create_table.columns[idx].type = parse_type(scanner);
        if (stmt->data.create_table.columns[idx].type == TYPE_NULL) {
            statement_destroy(stmt);
            return NULL;
        }
        
        stmt->data.create_table.column_count++;
        
    } while (expect_char(scanner, ','));
    
    if (!expect_char(scanner, ')')) {
        statement_destroy(stmt);
        return NULL;
    }
    
    return stmt;
}

static Statement* parse_insert(Scanner* scanner) {
    Statement* stmt = malloc(sizeof(Statement));
    if (!stmt) return NULL;
    
    stmt->type = STMT_INSERT;
    
    if (!match_keyword(scanner, "INTO")) {
        free(stmt);
        return NULL;
    }
    
    stmt->data.insert.table_name = parse_identifier(scanner);
    if (!stmt->data.insert.table_name) {
        free(stmt);
        return NULL;
    }
    
    if (!match_keyword(scanner, "VALUES")) {
        free(stmt->data.insert.table_name);
        free(stmt);
        return NULL;
    }
    
    if (!expect_char(scanner, '(')) {
        free(stmt->data.insert.table_name);
        free(stmt);
        return NULL;
    }
    
    // Parse values
    stmt->data.insert.values = NULL;
    stmt->data.insert.value_count = 0;
    size_t capacity = 0;
    
    do {
        if (stmt->data.insert.value_count >= capacity) {
            capacity = capacity ? capacity * 2 : 4;
            Value* new_vals = realloc(stmt->data.insert.values,
                                      capacity * sizeof(Value));
            if (!new_vals) {
                statement_destroy(stmt);
                return NULL;
            }
            stmt->data.insert.values = new_vals;
        }
        
        Value* val = parse_value(scanner);
        if (!val) {
            statement_destroy(stmt);
            return NULL;
        }
        
        stmt->data.insert.values[stmt->data.insert.value_count++] = *val;
        free(val);
        
    } while (expect_char(scanner, ','));
    
    if (!expect_char(scanner, ')')) {
        statement_destroy(stmt);
        return NULL;
    }
    
    return stmt;
}

static Statement* parse_select(Scanner* scanner) {
    Statement* stmt = malloc(sizeof(Statement));
    if (!stmt) return NULL;
    
    stmt->type = STMT_SELECT;
    stmt->data.select.columns = NULL;
    stmt->data.select.column_count = 0;
    stmt->data.select.where_clause = NULL;
    
    // Parse column list or *
    skip_whitespace(scanner);
    if (peek(scanner) == '*') {
        advance(scanner);
        stmt->data.select.column_count = 0;
    } else {
        // TODO: Parse column list
    }
    
    if (!match_keyword(scanner, "FROM")) {
        statement_destroy(stmt);
        return NULL;
    }
    
    stmt->data.select.table_name = parse_identifier(scanner);
    if (!stmt->data.select.table_name) {
        statement_destroy(stmt);
        return NULL;
    }
    
    // TODO: Parse WHERE clause
    
    return stmt;
}

Statement* parse_sql(const char* sql) {
    Scanner scanner;
    scanner_init(&scanner, sql);
    
    skip_whitespace(&scanner);
    
    if (match_keyword(&scanner, "CREATE")) {
        if (match_keyword(&scanner, "TABLE")) {
            return parse_create_table(&scanner);
        }
    } else if (match_keyword(&scanner, "INSERT")) {
        return parse_insert(&scanner);
    } else if (match_keyword(&scanner, "SELECT")) {
        return parse_select(&scanner);
    }
    
    return NULL;
}

void statement_destroy(Statement* stmt) {
    if (!stmt) {
        return;
    }
    
    switch (stmt->type) {
        case STMT_CREATE_TABLE:
            free(stmt->data.create_table.table_name);
            for (uint32_t i = 0; i < stmt->data.create_table.column_count; i++) {
                free(stmt->data.create_table.columns[i].name);
            }
            free(stmt->data.create_table.columns);
            break;
            
        case STMT_INSERT:
            free(stmt->data.insert.table_name);
            for (uint32_t i = 0; i < stmt->data.insert.value_count; i++) {
                if (stmt->data.insert.values[i].type == TYPE_TEXT) {
                    free(stmt->data.insert.values[i].value.text.data);
                }
            }
            free(stmt->data.insert.values);
            break;
            
        case STMT_SELECT:
            free(stmt->data.select.table_name);
            for (uint32_t i = 0; i < stmt->data.select.column_count; i++) {
                free(stmt->data.select.columns[i]);
            }
            free(stmt->data.select.columns);
            expr_destroy(stmt->data.select.where_clause);
            break;
    }
    
    free(stmt);
}

void expr_destroy(Expr* expr) {
    if (!expr) {
        return;
    }
    
    switch (expr->type) {
        case EXPR_LITERAL:
            if (expr->data.literal.type == TYPE_TEXT) {
                free(expr->data.literal.value.text.data);
            }
            break;
            
        case EXPR_COLUMN:
            free(expr->data.column.table);
            free(expr->data.column.column);
            break;
            
        case EXPR_BINARY_OP:
            expr_destroy(expr->data.binary.left);
            expr_destroy(expr->data.binary.right);
            break;
    }
    
    free(expr);
}
/* END src/parser.c */

/* BEGIN src/query.c */
/* BEGIN query.h */
#ifndef RISTRETTO_QUERY_H
#define RISTRETTO_QUERY_H

/* BEGIN db.h */
#ifndef RISTRETTO_DB_H
#define RISTRETTO_DB_H


typedef struct RistrettoDB RistrettoDB;

typedef enum {
    RISTRETTO_OK = 0,
    RISTRETTO_ERROR = -1,
    RISTRETTO_NOMEM = -2,
    RISTRETTO_IO_ERROR = -3,
    RISTRETTO_PARSE_ERROR = -4,
    RISTRETTO_NOT_FOUND = -5,
    RISTRETTO_CONSTRAINT_ERROR = -6
} RistrettoResult;

RistrettoDB* ristretto_open(const char* filename);
void ristretto_close(RistrettoDB* db);

RistrettoResult ristretto_exec(RistrettoDB* db, const char* sql);

typedef void (*RistrettoCallback)(void* ctx, int n_cols, char** values, char** col_names);
RistrettoResult ristretto_query(RistrettoDB* db, const char* sql, RistrettoCallback callback, void* ctx);

const char* ristretto_error_string(RistrettoResult result);

#endif

/* END db.h */

typedef enum {
    PLAN_TABLE_SCAN,
    PLAN_INDEX_SCAN,
    PLAN_INSERT,
    PLAN_CREATE_TABLE
} PlanType;

typedef struct QueryPlan {
    PlanType type;
    Table *table;
    union {
        struct {
            Expr *filter;
            uint32_t *columns;
            uint32_t column_count;
        } scan;
        struct {
            Value *values;
            uint32_t value_count;
        } insert;
        struct {
            CreateTableStmt *stmt;
        } create_table;
    } data;
} QueryPlan;

typedef struct {
    RistrettoDB *db;
    Pager *pager;
    QueryPlan *plan;
    RistrettoCallback callback;
    void *callback_ctx;
} QueryContext;

QueryPlan* plan_statement(Statement *stmt, RistrettoDB *db);
void plan_destroy(QueryPlan *plan);

RistrettoResult execute_plan(QueryContext *ctx);

bool evaluate_expr(Expr *expr, Row *row, Table *table);

#endif

/* END query.h */

typedef struct {
    char name[64];
    Table* table;
} TableEntry;

typedef struct {
    TableEntry* entries;
    uint32_t count;
    uint32_t capacity;
} TableCatalog;

static TableCatalog* get_catalog(RistrettoDB* db) {
    // For now, use a global catalog per process
    // In a real implementation, this would be stored in the database file
    static TableCatalog catalog = {NULL, 0, 0};
    (void)db; // Suppress unused parameter warning
    return &catalog;
}

static Table* find_table(RistrettoDB* db, const char* name) {
    TableCatalog* catalog = get_catalog(db);
    
    for (uint32_t i = 0; i < catalog->count; i++) {
        if (strcmp(catalog->entries[i].name, name) == 0) {
            return catalog->entries[i].table;
        }
    }
    
    return NULL;
}

static bool register_table(RistrettoDB* db, Table* table) {
    TableCatalog* catalog = get_catalog(db);
    
    if (catalog->count >= catalog->capacity) {
        uint32_t new_cap = catalog->capacity ? catalog->capacity * 2 : 4;
        TableEntry* new_entries = realloc(catalog->entries, new_cap * sizeof(TableEntry));
        if (!new_entries) return false;
        catalog->entries = new_entries;
        catalog->capacity = new_cap;
    }
    
    strncpy(catalog->entries[catalog->count].name, table->name, 63);
    catalog->entries[catalog->count].name[63] = '\0';
    catalog->entries[catalog->count].table = table;
    catalog->count++;
    
    return true;
}

QueryPlan* plan_statement(Statement* stmt, RistrettoDB* db) {
    QueryPlan* plan = malloc(sizeof(QueryPlan));
    if (!plan) return NULL;
    
    switch (stmt->type) {
        case STMT_CREATE_TABLE:
            plan->type = PLAN_CREATE_TABLE;
            plan->data.create_table.stmt = &stmt->data.create_table;
            plan->table = NULL;
            break;
            
        case STMT_INSERT:
            plan->type = PLAN_INSERT;
            plan->table = find_table(db, stmt->data.insert.table_name);
            if (!plan->table) {
                free(plan);
                return NULL;
            }
            plan->data.insert.values = stmt->data.insert.values;
            plan->data.insert.value_count = stmt->data.insert.value_count;
            break;
            
        case STMT_SELECT:
            plan->type = PLAN_TABLE_SCAN;
            plan->table = find_table(db, stmt->data.select.table_name);
            if (!plan->table) {
                free(plan);
                return NULL;
            }
            plan->data.scan.filter = stmt->data.select.where_clause;
            plan->data.scan.columns = NULL;
            plan->data.scan.column_count = 0;
            break;
            
        default:
            free(plan);
            return NULL;
    }
    
    return plan;
}

void plan_destroy(QueryPlan* plan) {
    if (!plan) {
        return;
    }
    
    switch (plan->type) {
        case PLAN_TABLE_SCAN:
        case PLAN_INDEX_SCAN:
            free(plan->data.scan.columns);
            // Filter is owned by the statement, not the plan
            break;
            
        case PLAN_INSERT:
            // Values are owned by the statement, not the plan
            break;
            
            
        case PLAN_CREATE_TABLE:
            // CreateTableStmt is owned by the statement, not the plan
            break;
    }
    
    free(plan);
}

static RistrettoResult execute_create_table(QueryContext* ctx) {
    CreateTableStmt* stmt = ctx->plan->data.create_table.stmt;
    
    // Check if table already exists
    if (find_table(ctx->db, stmt->table_name)) {
        return RISTRETTO_CONSTRAINT_ERROR;
    }
    
    // Create new table
    Table* table = storage_table_create(stmt->table_name);
    if (!table) {
        return RISTRETTO_NOMEM;
    }
    
    // Add columns
    for (uint32_t i = 0; i < stmt->column_count; i++) {
        storage_table_add_column(table, stmt->columns[i].name, stmt->columns[i].type);
    }
    
    // Register table
    if (!register_table(ctx->db, table)) {
        storage_table_destroy(table);
        return RISTRETTO_ERROR;
    }
    
    return RISTRETTO_OK;
}

static RistrettoResult execute_insert(QueryContext* ctx) {
    Table* table = ctx->plan->table;
    Value* values = ctx->plan->data.insert.values;
    uint32_t value_count = ctx->plan->data.insert.value_count;
    
    // Check column count
    if (value_count != table->column_count) {
        return RISTRETTO_CONSTRAINT_ERROR;
    }
    
    // Check type compatibility
    for (uint32_t i = 0; i < value_count; i++) {
        DataType expected = table->columns[i].type;
        DataType actual = values[i].type;
        
        // Allow NULL for any type
        if (actual == TYPE_NULL) continue;
        
        // Check type match
        if (expected != actual) {
            // Allow some conversions
            if (expected == TYPE_REAL && actual == TYPE_INTEGER) {
                // Convert integer to real
                values[i].type = TYPE_REAL;
                values[i].value.real = (double)values[i].value.integer;
            } else {
                return RISTRETTO_CONSTRAINT_ERROR;
            }
        }
    }
    
    // Create row
    Row* row = storage_row_create(table);
    if (!row) {
        return RISTRETTO_NOMEM;
    }
    
    // Set values
    for (uint32_t i = 0; i < value_count; i++) {
        storage_row_set_value(row, table, i, &values[i]);
    }
    
    // Insert row into storage
    RowId row_id = table_insert_row(table, ctx->pager, row);
    storage_row_destroy(row);
    
    if (row_id.page_id == 0) {
        return RISTRETTO_ERROR; // Failed to insert
    }
    
    return RISTRETTO_OK;
}

static char* value_to_string(Value* value) {
    if (!value) return strdup("NULL");
    
    switch (value->type) {
        case TYPE_NULL:
            return strdup("NULL");
        case TYPE_INTEGER: {
            char* str = malloc(32);
            snprintf(str, 32, "%lld", (long long)value->value.integer);
            return str;
        }
        case TYPE_REAL: {
            char* str = malloc(32);
            snprintf(str, 32, "%.6g", value->value.real);
            return str;
        }
        case TYPE_TEXT:
            return strdup(value->value.text.data ? value->value.text.data : "NULL");
        default:
            return strdup("?");
    }
}

static RistrettoResult execute_select(QueryContext* ctx) {
    Table* table = ctx->plan->table;
    
    if (!ctx->callback) {
        return RISTRETTO_OK; // No callback to send results to
    }
    
    // Prepare column names
    char** col_names = malloc(table->column_count * sizeof(char*));
    if (!col_names) return RISTRETTO_NOMEM;
    
    for (uint32_t i = 0; i < table->column_count; i++) {
        col_names[i] = table->columns[i].name;
    }
    
    // Scan the table
    TableScanner* scanner = table_scanner_create(table, ctx->pager);
    if (!scanner) {
        free(col_names);
        return RISTRETTO_NOMEM;
    }
    
    while (!table_scanner_at_end(scanner)) {
        Row* row = table_scanner_next(scanner);
        if (!row) break;
        
        // Convert row values to strings
        char** values = malloc(table->column_count * sizeof(char*));
        if (!values) {
            storage_row_destroy(row);
            continue;
        }
        
        for (uint32_t i = 0; i < table->column_count; i++) {
            Value* val = storage_row_get_value(row, table, i);
            values[i] = value_to_string(val);
            storage_value_destroy(val);
        }
        
        // Call the callback
        ctx->callback(ctx->callback_ctx, table->column_count, values, col_names);
        
        // Clean up
        for (uint32_t i = 0; i < table->column_count; i++) {
            free(values[i]);
        }
        free(values);
        storage_row_destroy(row);
    }
    
    table_scanner_destroy(scanner);
    free(col_names);
    return RISTRETTO_OK;
}

RistrettoResult execute_plan(QueryContext* ctx) {
    if (!ctx || !ctx->plan) {
        return RISTRETTO_ERROR;
    }
    
    switch (ctx->plan->type) {
        case PLAN_CREATE_TABLE:
            return execute_create_table(ctx);
            
        case PLAN_INSERT:
            return execute_insert(ctx);
            
        case PLAN_TABLE_SCAN:
            return execute_select(ctx);
            
        default:
            return RISTRETTO_ERROR;
    }
}

bool evaluate_expr(Expr* expr, Row* row, Table* table) {
    // TODO: Implement expression evaluation
    // For now, return false
    (void)expr;
    (void)row;
    (void)table;
    return false;
}

/* END src/query.c */

/* BEGIN src/db.c */

struct RistrettoDB {
    Pager* pager;
    Table** tables;
    uint32_t table_count;
    uint32_t table_capacity;
};

RistrettoDB* ristretto_open(const char* filename) {
    RistrettoDB* db = malloc(sizeof(RistrettoDB));
    if (!db) {
        return NULL;
    }
    
    db->pager = pager_open(filename);
    if (!db->pager) {
        free(db);
        return NULL;
    }
    
    db->tables = NULL;
    db->table_count = 0;
    db->table_capacity = 0;
    
    return db;
}

void ristretto_close(RistrettoDB* db) {
    if (!db) {
        return;
    }
    
    if (db->pager) {
        pager_close(db->pager);
    }
    
    for (uint32_t i = 0; i < db->table_count; i++) {
        storage_table_destroy(db->tables[i]);
    }
    free(db->tables);
    
    free(db);
}

RistrettoResult ristretto_exec(RistrettoDB* db, const char* sql) {
    Statement* stmt = parse_sql(sql);
    if (!stmt) {
        return RISTRETTO_PARSE_ERROR;
    }
    
    QueryPlan* plan = plan_statement(stmt, db);
    if (!plan) {
        statement_destroy(stmt);
        return RISTRETTO_ERROR;
    }
    
    QueryContext ctx = {
        .db = db,
        .pager = db->pager,
        .plan = plan,
        .callback = NULL,
        .callback_ctx = NULL
    };
    
    RistrettoResult result = execute_plan(&ctx);
    
    plan_destroy(plan);
    statement_destroy(stmt);
    
    return result;
}

RistrettoResult ristretto_query(RistrettoDB* db, const char* sql, 
                                RistrettoCallback callback, void* ctx) {
    Statement* stmt = parse_sql(sql);
    if (!stmt) {
        return RISTRETTO_PARSE_ERROR;
    }
    
    QueryPlan* plan = plan_statement(stmt, db);
    if (!plan) {
        statement_destroy(stmt);
        return RISTRETTO_ERROR;
    }
    
    QueryContext query_ctx = {
        .db = db,
        .pager = db->pager,
        .plan = plan,
        .callback = callback,
        .callback_ctx = ctx
    };
    
    RistrettoResult result = execute_plan(&query_ctx);
    
    plan_destroy(plan);
    statement_destroy(stmt);
    
    return result;
}

const char* ristretto_error_string(RistrettoResult result) {
    switch (result) {
        case RISTRETTO_OK:
            return "Success";
        case RISTRETTO_ERROR:
            return "General error";
        case RISTRETTO_NOMEM:
            return "Out of memory";
        case RISTRETTO_IO_ERROR:
            return "I/O error";
        case RISTRETTO_PARSE_ERROR:
            return "SQL parse error";
        case RISTRETTO_NOT_FOUND:
            return "Not found";
        case RISTRETTO_CONSTRAINT_ERROR:
            return "Constraint violation";
        default:
            return "Unknown error";
    }
}

/* END src/db.c */
